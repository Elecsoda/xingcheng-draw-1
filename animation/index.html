<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¡Œç¨‹é—®é¢˜æ¼”ç¤ºå·¥å…·</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Comic Sans MS', 'Ma Shan Zheng', 'Segoe UI', Roboto, sans-serif; background-color: #fffbeb; touch-action: manipulation; }
        .track-bg { background-color: #ffffff; border-radius: 16px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); }
        .tabular-nums { font-variant-numeric: tabular-nums; }
        .no-select { user-select: none; -webkit-user-select: none; }
        .height-transition { transition: height 0.3s ease-out; }
        /* ä¼˜åŒ–è¾“å…¥æ¡† */
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; }
        /* æ–‡å­—æè¾¹ï¼Œå¢åŠ å¯è¯»æ€§ */
        .text-halo { text-shadow: 0 0 3px white, 0 0 3px white, 0 0 3px white, 0 0 3px white; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- å›¾æ ‡ ---
        const Icon = ({ path, size=20 }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round">
                {path}
            </svg>
        );
        const Icons = {
            Play: <polygon points="5 3 19 12 5 21 5 3" />,
            Pause: <g><rect x="6" y="4" width="4" height="16" /><rect x="14" y="4" width="4" height="16" /></g>,
            Reset: <g><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" /><path d="M3 3v5h5" /></g>,
            Continue: <path d="M13 5l7 7-7 7M5 12h14" />
        };

        const DEFAULTS = {
            distance: 400,
            speedA: 50,
            speedB: 30,
            headStart: 100
        };

        const App = () => {
            // --- çŠ¶æ€ ---
            const [mode, setMode] = useState('meeting'); 
            const [trackType, setTrackType] = useState('linear'); // 'linear' | 'circular'
            
            // åŸºç¡€å‚æ•°
            const [distance, setDistance] = useState(DEFAULTS.distance); 
            const [speedA, setSpeedA] = useState(DEFAULTS.speedA); 
            const [speedB, setSpeedB] = useState(DEFAULTS.speedB); 
            const [headStart, setHeadStart] = useState(DEFAULTS.headStart); 

            // æ¼”ç¤ºæ§åˆ¶
            const [simSpeed, setSimSpeed] = useState(1); 
            const [showMarkers, setShowMarkers] = useState(true);

            // å®æ—¶çŠ¶æ€
            const [posA, setPosA] = useState(0); 
            const [posB, setPosB] = useState(0); 
            const [dirA, setDirA] = useState(1); 
            const [dirB, setDirB] = useState(-1);
            const [totalDistA, setTotalDistA] = useState(0); 
            const [totalDistB, setTotalDistB] = useState(0);
            const [currentTime, setCurrentTime] = useState(0); 
            const [meetCount, setMeetCount] = useState(0);
            
            // è½¨è¿¹ä¸å†å²
            const [turnPointsA, setTurnPointsA] = useState([]);
            const [turnPointsB, setTurnPointsB] = useState([]);
            const [meetingHistory, setMeetingHistory] = useState([]);
            
            const [isRunning, setIsRunning] = useState(false);
            const [isPausedAtEvent, setIsPausedAtEvent] = useState(false);

            const requestRef = useRef();
            const lastTimeRef = useRef();
            
            // ä½¿ç”¨ ref å­˜å‚¨æœ€æ–°é…ç½®ï¼Œä¾›ç‰©ç†å¼•æ“å®æ—¶è¯»å–
            const latestConfig = useRef({
                mode, trackType, distance, speedA, speedB, simSpeed
            });

            useEffect(() => {
                latestConfig.current = { mode, trackType, distance, speedA, speedB, simSpeed };
            }, [mode, trackType, distance, speedA, speedB, simSpeed]);

            const physicsState = useRef({ 
                posA: 0, posB: 0, 
                dirA: 1, dirB: -1, 
                totalDistA: 0, totalDistB: 0, 
                time: 0,
                turnsA: [], turnsB: []
            });

            // --- é‡ç½® ---
            const resetPositions = (targetMode = mode, resetParams = false) => {
                setIsRunning(false);
                setIsPausedAtEvent(false);
                setCurrentTime(0);
                setMeetCount(0);
                setMeetingHistory([]);
                lastTimeRef.current = undefined;

                if (resetParams) {
                    setDistance(DEFAULTS.distance);
                    setSpeedA(DEFAULTS.speedA);
                    setSpeedB(DEFAULTS.speedB);
                    setHeadStart(DEFAULTS.headStart);
                }

                const d = resetParams ? DEFAULTS.distance : distance;
                const hs = resetParams ? DEFAULTS.headStart : headStart;

                let startA = 0;
                let startB = 0;
                let dA = 1;
                let dB = -1;

                if (targetMode === 'meeting') {
                    startA = 0; startB = d; dA = 1; dB = -1;
                } else { 
                    startA = 0; startB = hs; dA = 1; dB = 1;
                }

                const initTurnsA = [{ pos: startA, totalDist: 0 }];
                const initTurnsB = [{ pos: startB, totalDist: 0 }];

                setPosA(startA); setPosB(startB);
                setDirA(dA); setDirB(dB);
                setTotalDistA(0); setTotalDistB(0);
                setTurnPointsA(initTurnsA);
                setTurnPointsB(initTurnsB);

                physicsState.current = { 
                    posA: startA, posB: startB, 
                    dirA: dA, dirB: dB, 
                    totalDistA: 0, totalDistB: 0, 
                    time: 0,
                    turnsA: JSON.parse(JSON.stringify(initTurnsA)), 
                    turnsB: JSON.parse(JSON.stringify(initTurnsB))
                };
            };

            // ä»…å½“ distance/headStart æ”¹å˜ä¸”ä¸åœ¨è¿è¡Œæ—¶é‡ç½®ä½ç½®
            useEffect(() => {
                if (!isRunning && !isPausedAtEvent) resetPositions(mode, false);
            }, [distance, headStart]);

            const handleModeChange = (newMode) => {
                setMode(newMode);
                resetPositions(newMode, true);
            };

            const handleTrackChange = (newTrack) => {
                setTrackType(newTrack);
                resetPositions(mode, false);
            };

            // --- ç‰©ç†å¼•æ“ ---
            const loop = (timestamp) => {
                if (!lastTimeRef.current) lastTimeRef.current = timestamp;
                const rawDt = (timestamp - lastTimeRef.current) / 1000;
                lastTimeRef.current = timestamp;
                
                const cfg = latestConfig.current;
                let timeLeft = Math.min(rawDt, 0.1) * cfg.simSpeed;
                let state = physicsState.current;
                let hasPaused = false;

                while (timeLeft > 1e-9 && !hasPaused) {
                    const { posA, posB, dirA, dirB } = state;
                    const vA = cfg.speedA * dirA;
                    const vB = cfg.speedB * dirB;
                    const dist = cfg.distance;

                    let tWallA = Infinity;
                    let tWallB = Infinity;

                    // 1. å¢™å£æ£€æµ‹
                    if (cfg.trackType === 'linear' && cfg.mode === 'meeting') {
                        if (dirA === 1) tWallA = (dist - posA) / vA;
                        else tWallA = posA / -vA;

                        if (dirB === 1) tWallB = (dist - posB) / vB;
                        else tWallB = posB / -vB;
                    } 

                    // 2. é¢„æµ‹ç›¸é‡ (ä»…ç›´çº¿)
                    let tCol = Infinity;
                    const relV = vA - vB;
                    const relPos = posA - posB; 

                    if (cfg.trackType === 'linear') {
                        if (Math.abs(relV) > 1e-9) {
                            const t = -relPos / relV;
                            if (t > 1e-10) tCol = t;
                        }
                    } 

                    const events = [
                        { type: 'wallA', t: tWallA },
                        { type: 'wallB', t: tWallB },
                        { type: 'col', t: tCol }
                    ].filter(e => e.t <= timeLeft && e.t >= 0);

                    events.sort((a, b) => a.t - b.t);
                    const nextEvent = events[0];

                    const step = nextEvent ? nextEvent.t : timeLeft;
                    
                    const prevPosA = state.posA;
                    const prevPosB = state.posB;

                    // ç§»åŠ¨
                    state.posA += vA * step;
                    state.posB += vB * step;
                    state.totalDistA += Math.abs(vA * step); 
                    state.totalDistB += Math.abs(vB * step);
                    state.time += step;
                    
                    timeLeft -= step;

                    // å¤„ç†äº‹ä»¶
                    if (nextEvent) {
                        if (nextEvent.type === 'wallA') {
                            state.posA = (dirA === 1) ? dist : 0;
                            state.dirA *= -1;
                            if (state.turnsA.length === 0 || state.turnsA[state.turnsA.length - 1].pos !== state.posA) {
                                state.turnsA.push({ pos: state.posA, totalDist: state.totalDistA });
                            }
                        } else if (nextEvent.type === 'wallB') {
                            state.posB = (dirB === 1) ? dist : 0;
                            state.dirB *= -1;
                            if (state.turnsB.length === 0 || state.turnsB[state.turnsB.length - 1].pos !== state.posB) {
                                state.turnsB.push({ pos: state.posB, totalDist: state.totalDistB });
                            }
                        } else if (nextEvent.type === 'col') {
                            triggerCollision(state);
                            hasPaused = true;
                        }
                    } else {
                        // 3. ç©¿é€æ£€æµ‹
                        const currDiff = state.posA - state.posB;
                        const prevDiff = prevPosA - prevPosB;

                        if (cfg.trackType === 'linear') {
                            if (Math.sign(currDiff) !== Math.sign(prevDiff)) {
                                const totalDiffChange = Math.abs(currDiff - prevDiff);
                                const fraction = Math.abs(prevDiff) / totalDiffChange;
                                const backStep = step * (1 - fraction);
                                
                                rewindState(state, backStep, vA, vB);
                                state.posA = state.posB = (state.posA + state.posB) / 2;
                                triggerCollision(state);
                                hasPaused = true;
                            }
                        } else {
                            // ç¯å½¢æ£€æµ‹
                            const kPrev = Math.floor(prevDiff / dist);
                            const kCurr = Math.floor(currDiff / dist);
                            
                            if (kPrev !== kCurr) {
                                const relV = vA - vB;
                                let targetBoundaryK;
                                
                                if (relV > 0) targetBoundaryK = kPrev + 1;
                                else targetBoundaryK = kPrev;

                                const targetDiff = targetBoundaryK * dist;
                                
                                const totalChange = currDiff - prevDiff;
                                if (Math.abs(totalChange) > 1e-9) {
                                    const fraction = (targetDiff - prevDiff) / totalChange;
                                    if (fraction >= 0 && fraction <= 1) {
                                        const backStep = step * (1 - fraction);
                                        rewindState(state, backStep, vA, vB);
                                        triggerCollision(state);
                                        hasPaused = true;
                                    }
                                }
                            }
                        }
                    }
                }

                setPosA(state.posA); setPosB(state.posB);
                setDirA(state.dirA); setDirB(state.dirB);
                setTotalDistA(state.totalDistA); setTotalDistB(state.totalDistB);
                setCurrentTime(state.time);
                
                if (turnPointsA.length !== state.turnsA.length) setTurnPointsA([...state.turnsA]);
                if (turnPointsB.length !== state.turnsB.length) setTurnPointsB([...state.turnsB]);

                if (!hasPaused) {
                    requestRef.current = requestAnimationFrame(loop);
                } else {
                    lastTimeRef.current = undefined;
                }
            };

            const rewindState = (state, backStep, vA, vB) => {
                state.posA -= vA * backStep;
                state.posB -= vB * backStep;
                state.totalDistA -= Math.abs(vA * backStep);
                state.totalDistB -= Math.abs(vB * backStep);
                state.time -= backStep;
            };

            const triggerCollision = (state) => {
                const cfg = latestConfig.current;
                
                if (cfg.trackType === 'linear') {
                    state.posA = state.posB = (state.posA + state.posB) / 2;
                }
                
                const newCount = meetCount + 1;
                setMeetCount(newCount);
                setMeetingHistory(prev => [...prev, {
                    count: newCount,
                    pos: state.posA,
                    totalDistA: state.totalDistA,
                    totalDistB: state.totalDistB,
                    time: state.time
                }]);
                setIsRunning(false);
                setIsPausedAtEvent(true);
            };

            useEffect(() => {
                if (isRunning) requestRef.current = requestAnimationFrame(loop);
                else { cancelAnimationFrame(requestRef.current); lastTimeRef.current = undefined; }
                return () => cancelAnimationFrame(requestRef.current);
            }, [isRunning]);

            const handleContinue = () => {
                const nudge = 0.05; 
                let state = physicsState.current;
                const cfg = latestConfig.current;
                
                state.posA += cfg.speedA * state.dirA * nudge;
                state.posB += cfg.speedB * state.dirB * nudge;
                state.totalDistA += Math.abs(cfg.speedA * nudge);
                state.totalDistB += Math.abs(cfg.speedB * nudge);
                state.time += nudge;
                
                if (cfg.trackType === 'linear' && cfg.mode === 'meeting') {
                    if(state.posA > cfg.distance) state.posA = cfg.distance; 
                    if(state.posA < 0) state.posA = 0;
                    if(state.posB > cfg.distance) state.posB = cfg.distance; 
                    if(state.posB < 0) state.posB = 0;
                }

                setPosA(state.posA); setPosB(state.posB);
                setTotalDistA(state.totalDistA); setTotalDistB(state.totalDistB);
                
                setIsPausedAtEvent(false);
                setIsRunning(true);
            };
            // è®¡ç®—è§†å›¾èŒƒå›´ï¼šè¿½åŠæ¨¡å¼ä¸‹æ— é™å»¶ä¼¸
            const viewMax = (mode === 'catching' && trackType === 'linear') 
                ? Math.max(distance + 100, posA + 100, posB + 100)
                : distance;

            // ç¯å½¢è·‘é“å‚æ•°è°ƒæ•´ï¼š
            // ä¿®æ­£ï¼šå¤§å¹…ç¼©å°é—´è·ï¼Œé¿å…å­¦ç”Ÿäº§ç”Ÿ"å¤–åœˆè·‘æ›´è¿œ"çš„è¯¯è§£
            const spiralGap = 5; // èºæ—‹é—´è·ç¼©å°åˆ° 5pxï¼Œç´§è´´æ˜¾ç¤º
            // ä¸»è·‘é“ r=180
            const circleRadiusA = 175; // å†…åœˆåŸºå‡† (ç´§è´´ä¸»è·‘é“å†…ä¾§)
            const circleRadiusB = 185; // å¤–åœˆåŸºå‡† (ç´§è´´ä¸»è·‘é“å¤–ä¾§)
            
            const blueBaseY = 35;
            const lineHeight = 20; 
            const blueLinesCount = turnPointsA.length;
            const blueMaxY = blueBaseY + (blueLinesCount - 1) * lineHeight;
            const redBaseY = Math.max(blueBaseY + 40, blueBaseY + (blueLinesCount - 1) * lineHeight + 30);
            const redLinesCount = turnPointsB.length;
            const redMaxY = redBaseY + (redLinesCount - 1) * lineHeight;
            
            // å¢åŠ å®¹å™¨é«˜åº¦ä»¥é€‚åº”æ›´å¤§çš„ç¯å½¢è·‘é“
            const dynamicContainerHeight = trackType === 'circular' ? 600 : Math.max(260, redMaxY + 150);

            const getCirclePos = (linearPos, radius) => {
                const pct = linearPos / distance;
                const angleRad = pct * 2 * Math.PI - Math.PI / 2;
                const x = Math.cos(angleRad) * radius;
                const y = Math.sin(angleRad) * radius;
                const rotation = (angleRad * 180) / Math.PI;
                return { x, y, rotation, angleRad };
            };

            const renderLinearMarkers = (track, segmentStart, segmentEnd, startX, endX, y) => {
                if (!showMarkers) return null;
                const minD = Math.min(segmentStart, segmentEnd);
                const maxD = Math.max(segmentStart, segmentEnd);

                return meetingHistory.filter(m => {
                    const d = track === 'A' ? m.totalDistA : m.totalDistB;
                    return d >= minD - 0.01 && d <= maxD + 0.01;
                }).map((m, i) => {
                    const d = track === 'A' ? m.totalDistA : m.totalDistB;
                    let ratio = 0;
                    if (Math.abs(segmentEnd - segmentStart) > 0.01) ratio = (d - segmentStart) / (segmentEnd - segmentStart);
                    const mx = startX + ratio * (endX - startX);
                    return (
                        <g key={i}>
                            <circle cx={`${(mx/viewMax)*100}%`} cy={y} r="3" fill="red" stroke="white" strokeWidth="1" />
                            <text x={`${(mx/viewMax)*100}%`} y={y - 7} fontSize="8" fill="red" textAnchor="middle" fontWeight="bold">{m.count}</text>
                            <text x={`${(mx/viewMax)*100}%`} y={y + 9} fontSize="7" fill="#666" textAnchor="middle">{Math.round(d)}m</text>
                            <text x={`${(mx/viewMax)*100}%`} y={y + 17} fontSize="7" fill="#999" textAnchor="middle">{m.time.toFixed(1)}s</text>
                        </g>
                    );
                });
            };

            const renderCircularMarkers = (track, segmentStart, segmentEnd, radius) => {
                if (!showMarkers) return null;
                const minD = Math.min(segmentStart, segmentEnd);
                const maxD = Math.max(segmentStart, segmentEnd);

                return meetingHistory.filter(m => {
                    const d = track === 'A' ? m.totalDistA : m.totalDistB;
                    // åœ¨ç¯å½¢è·‘é“ï¼Œæˆ‘ä»¬é€šè¿‡æ€»é‡Œç¨‹æ¥åˆ¤æ–­è¿™ä¸ªæ ‡è®°æ˜¯å¦å±äºå½“å‰è¿™ä¸€åœˆï¼ˆæ®µï¼‰
                    return d >= minD - 0.01 && d <= maxD + 0.01;
                }).map((m, i) => {
                    const d = track === 'A' ? m.totalDistA : m.totalDistB;
                    const laps = (d / distance).toFixed(1).replace(/\.0$/, '');
                    
                    const posInfo = getCirclePos(m.pos, radius);
                    
                    // ç­–ç•¥ï¼šçº¢åœˆ(B,å¤–åœˆ)æ–‡å­—å‘å¤–ï¼Œè“åœˆ(A,å†…åœˆ)æ–‡å­—å‘å†…
                    // ä¿®æ­£ï¼šè™½ç„¶è½¨è¿¹è´´çš„å¾ˆè¿‘ï¼Œä½†æ–‡å­—éœ€è¦æ¨è¿œä¸€ç‚¹ä»¥é˜²é®æŒ¡
                    // A(å†…åœˆ)æ–‡å­—è·ç¦»ç‚¹ 25pxï¼ŒB(å¤–åœˆ)æ–‡å­—è·ç¦»ç‚¹ 25px
                    const textR = track === 'B' ? radius + 25 : radius - 25;
                    const textX = Math.cos(posInfo.angleRad) * textR;
                    const textY = Math.sin(posInfo.angleRad) * textR;

                    const color = track === 'A' ? '#2563eb' : '#e11d48';

                    return (
                        <g key={i}>
                            {/* æ ‡è®°ç‚¹ */}
                            <circle cx={posInfo.x} cy={posInfo.y} r="4" fill="red" stroke="white" strokeWidth="2" />
                            
                            {/* æ–‡å­—ç»„ */}
                            <g transform={`translate(${textX}, ${textY})`}>
                                <text className="text-halo" y="-4" fontSize="10" fill={color} textAnchor="middle" fontWeight="bold">ç¬¬{m.count}æ¬¡</text>
                                <text className="text-halo" y="8" fontSize="10" fill={color} textAnchor="middle" fontWeight="bold">{laps}åœˆ</text>
                            </g>
                            
                            {/* å¯é€‰ï¼šåŠ ä¸€æ¡ç»†çº¿è¿æ¥ç‚¹å’Œæ–‡å­—ï¼Œå¢åŠ æ¸…æ™°åº¦ */}
                            <line x1={posInfo.x} y1={posInfo.y} x2={textX} y2={textY} stroke={color} strokeWidth="0.5" opacity="0.5" />
                        </g>
                    );
                });
            };

            const getArcPath = (startPos, endPos, radius, color) => {
                const absDiff = Math.abs(endPos - startPos);
                if (absDiff >= distance - 0.1) {
                    return <circle cx="0" cy="0" r={radius} fill="none" stroke={color} strokeWidth="3" opacity="0.6" />;
                }
                const startAngle = (startPos / distance) * 2 * Math.PI - Math.PI / 2;
                const endAngle = (endPos / distance) * 2 * Math.PI - Math.PI / 2;
                const startX = Math.cos(startAngle) * radius;
                const startY = Math.sin(startAngle) * radius;
                const endX = Math.cos(endAngle) * radius;
                const endY = Math.sin(endAngle) * radius;
                const diff = endPos - startPos;
                const sweepFlag = diff >= 0 ? 1 : 0;
                const angleDiff = (absDiff / distance) * 2 * Math.PI;
                const largeArcFlag = angleDiff > Math.PI ? 1 : 0;
                const d = `M ${startX} ${startY} A ${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${endX} ${endY}`;
                
                const markerId = color === '#2563eb' ? 'arrow-blue' : 'arrow-red';
                return <path d={d} fill="none" stroke={color} strokeWidth="3" markerEnd={`url(#${markerId})`} opacity="0.6" />;
            };

            return (
                <div className="min-h-screen p-2 md:p-8 max-w-4xl mx-auto flex flex-col">
                    <header className="mb-4 text-center">
                        <h1 className="text-2xl md:text-4xl font-bold text-amber-600 mb-2">ğŸƒ è¡Œç¨‹é—®é¢˜æ¼”ç¤ºå·¥å…·</h1>
                        <p className="text-xs md:text-base text-stone-500 font-bold">
                            {mode === 'meeting' ? 'ç›¸é‡é—®é¢˜ï¼šé¢å¯¹é¢è·‘ï¼Œçœ‹è°è·‘å¾—å¿«' : 'è¿½åŠé—®é¢˜ï¼šåœ¨åé¢è¿½ï¼Œçœ‹èƒ½ä¸èƒ½è¿½ä¸Š'}
                        </p>
                    </header>

                    {/* æ§åˆ¶é¢æ¿ */}
                    <div className="bg-white p-3 md:p-6 rounded-2xl shadow-lg border-2 border-amber-100 mb-4 select-none">
                        <div className="flex flex-col md:flex-row justify-center gap-4 mb-4">
                            <div className="bg-stone-100 p-1 rounded-xl flex gap-1">
                                <button onClick={() => handleModeChange('meeting')} className={`px-4 py-2 rounded-lg font-bold text-sm md:text-base transition-all ${mode === 'meeting' ? 'bg-white text-amber-600 shadow-sm' : 'text-stone-400 hover:text-stone-600'}`}>
                                    ğŸ¤ ç›¸é‡é—®é¢˜
                                </button>
                                <button onClick={() => handleModeChange('catching')} className={`px-4 py-2 rounded-lg font-bold text-sm md:text-base transition-all ${mode === 'catching' ? 'bg-white text-purple-600 shadow-sm' : 'text-stone-400 hover:text-stone-600'}`}>
                                    ğŸ¢ è¿½åŠé—®é¢˜
                                </button>
                            </div>
                            
                            <div className="bg-stone-100 p-1 rounded-xl flex gap-1">
                                <button onClick={() => handleTrackChange('linear')} className={`px-4 py-2 rounded-lg font-bold text-sm md:text-base transition-all flex items-center gap-1 ${trackType === 'linear' ? 'bg-white text-emerald-600 shadow-sm' : 'text-stone-400 hover:text-stone-600'}`}>
                                    ğŸ“ ç›´çº¿è·‘é“
                                </button>
                                <button onClick={() => handleTrackChange('circular')} className={`px-4 py-2 rounded-lg font-bold text-sm md:text-base transition-all flex items-center gap-1 ${trackType === 'circular' ? 'bg-white text-emerald-600 shadow-sm' : 'text-stone-400 hover:text-stone-600'}`}>
                                    â­• ç¯å½¢è·‘é“
                                </button>
                            </div>
                        </div>

                        {/* å‚æ•°è¾“å…¥åŒºåŸŸ */}
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-3">
                            <div className="space-y-1">
                                <label className="flex justify-between text-xs md:text-sm font-bold text-stone-600 items-center">
                                    <span>ğŸ {trackType === 'circular' ? 'è·‘é“å‘¨é•¿' : (mode === 'catching' ? 'è·‘é“æ˜¾ç¤ºé•¿åº¦' : 'ä¸¤åœ°è·ç¦»')}</span>
                                    <div className="flex items-center gap-1">
                                        <input type="number" value={distance} onChange={(e) => setDistance(Math.max(10, Number(e.target.value)))} disabled={isRunning || isPausedAtEvent} className="w-16 border rounded px-1 text-right text-amber-600 border-amber-200 focus:outline-none focus:border-amber-500 text-sm" />
                                        <span className="text-amber-600 text-xs md:text-sm">ç±³</span>
                                    </div>
                                </label>
                                <input type="range" min="100" max="2000" step="50" value={distance} onChange={e => setDistance(Number(e.target.value))} disabled={isRunning || isPausedAtEvent} className="w-full accent-amber-500 cursor-pointer h-6" />
                            </div>

                            {mode === 'catching' && (
                                <div className="space-y-1">
                                    <label className="flex justify-between text-xs md:text-sm font-bold text-stone-600 items-center">
                                        <span>ğŸ“ å°çº¢å…ˆè·‘ (å·®è·)</span>
                                        <div className="flex items-center gap-1">
                                            <input type="number" value={headStart} onChange={(e) => setHeadStart(Math.max(0, Number(e.target.value)))} disabled={isRunning || isPausedAtEvent} className="w-16 border rounded px-1 text-right text-purple-600 border-purple-200 focus:outline-none focus:border-purple-500 text-sm" />
                                            <span className="text-purple-600 text-xs md:text-sm">ç±³</span>
                                        </div>
                                    </label>
                                    <input type="range" min="0" max="1000" step="10" value={headStart} onChange={e => setHeadStart(Number(e.target.value))} disabled={isRunning || isPausedAtEvent} className="w-full accent-purple-500 cursor-pointer h-6" />
                                </div>
                            )}
                            
                            {mode !== 'catching' && <div className="hidden md:block"></div>}

                            <div className="space-y-1">
                                <label className="flex justify-between text-xs md:text-sm font-bold text-stone-600 items-center">
                                    <span>ğŸƒâ€â™‚ï¸ å°æ˜é€Ÿåº¦</span>
                                    <div className="flex items-center gap-1">
                                        <input type="number" value={speedA} onChange={(e) => setSpeedA(Math.max(1, Number(e.target.value)))} disabled={isRunning || isPausedAtEvent} className="w-16 border rounded px-1 text-right text-blue-600 border-blue-200 focus:outline-none focus:border-blue-500 text-sm" />
                                        <span className="text-blue-600 text-xs md:text-sm">ç±³/ç§’</span>
                                    </div>
                                </label>
                                <input type="range" min="1" max="200" value={speedA} onChange={e => setSpeedA(Number(e.target.value))} disabled={isRunning || isPausedAtEvent} className="w-full accent-blue-500 cursor-pointer h-6" />
                            </div>

                            <div className="space-y-1">
                                <label className="flex justify-between text-xs md:text-sm font-bold text-stone-600 items-center">
                                    <span>ğŸƒâ€â™€ï¸ å°çº¢é€Ÿåº¦</span>
                                    <div className="flex items-center gap-1">
                                        <input type="number" value={speedB} onChange={(e) => setSpeedB(Math.max(1, Number(e.target.value)))} disabled={isRunning || isPausedAtEvent} className="w-16 border rounded px-1 text-right text-rose-500 border-rose-200 focus:outline-none focus:border-rose-500 text-sm" />
                                        <span className="text-rose-500 text-xs md:text-sm">ç±³/ç§’</span>
                                    </div>
                                </label>
                                <input type="range" min="1" max="200" value={speedB} onChange={e => setSpeedB(Number(e.target.value))} disabled={isRunning || isPausedAtEvent} className="w-full accent-rose-400 cursor-pointer h-6" />
                            </div>
                        </div>

                        {/* åº•éƒ¨è®¾ç½® */}
                        <div className="mt-4 flex flex-wrap items-center justify-between border-t pt-4 border-stone-100 gap-2">
                            <div className="flex items-center gap-1 md:gap-2">
                                <span className="text-xs font-bold text-stone-400">å€é€Ÿ:</span>
                                {[0.5, 1, 2, 5].map(rate => (
                                    <button key={rate} onClick={() => setSimSpeed(rate)} className={`px-2 py-1 text-xs rounded border ${simSpeed === rate ? 'bg-stone-500 text-white border-stone-500' : 'bg-white text-stone-500 border-stone-200 hover:bg-stone-50'}`}>
                                        {rate}x
                                    </button>
                                ))}
                            </div>

                            <label className="flex items-center gap-2 cursor-pointer">
                                <span className="text-xs font-bold text-stone-500">æ˜¾ç¤ºæ ‡è®°</span>
                                <div className={`w-9 h-5 rounded-full p-0.5 transition-colors duration-300 ${showMarkers ? 'bg-green-500' : 'bg-stone-300'}`} onClick={() => setShowMarkers(!showMarkers)}>
                                    <div className={`w-4 h-4 bg-white rounded-full shadow-md transform transition-transform duration-300 ${showMarkers ? 'translate-x-4' : ''}`}></div>
                                </div>
                            </label>
                        </div>
                    </div>

                    {/* æ¼”ç¤ºåŒºåŸŸ */}
                    <div className="space-y-4 md:space-y-6">
                        <div className={`track-bg p-4 md:p-6 relative overflow-hidden border-2 border-stone-100 select-none height-transition ${trackType === 'circular' ? 'flex items-center justify-center' : ''}`} style={{ height: `${dynamicContainerHeight}px` }}>
                            <div className="absolute top-3 left-4 text-stone-400 text-xs md:text-sm font-bold flex gap-2 z-20">
                                {isPausedAtEvent 
                                    ? <span className="text-green-600 text-sm md:text-lg animate-bounce inline-block">ğŸš© ç¬¬ {meetCount} æ¬¡{mode === 'meeting' ? 'ç›¸é‡' : 'è¿½ä¸Š'}ï¼</span> 
                                    : (isRunning ? 'ğŸƒ æ­£åœ¨å¥”è·‘...' : 'ğŸ å‡†å¤‡å‡ºå‘')}
                            </div>

                            {/* é€šç”¨å®šä¹‰åŒºï¼šç¡®ä¿æ‰€æœ‰markeréƒ½èƒ½æ‰¾åˆ° */}
                            <svg className="absolute w-0 h-0">
                                <defs>
                                    <marker id="arrow-blue" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto"><path d="M0,0 L0,6 L6,3 z" fill="#2563eb" /></marker>
                                    <marker id="arrow-red" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto"><path d="M0,0 L0,6 L6,3 z" fill="#e11d48" /></marker>
                                </defs>
                            </svg>

                            {/* ç›´çº¿è·‘é“è§†å›¾ */}
                            {trackType === 'linear' && (
                                <div className="relative w-full h-1.5 bg-stone-300 rounded-full mt-12 z-10">
                                    <svg className="absolute left-0 top-0 w-full overflow-visible pointer-events-none" style={{ height: `${dynamicContainerHeight}px` }}>
                                        {turnPointsA.map((pt, i) => {
                                            const startX = pt.pos;
                                            const endX = (i === turnPointsA.length - 1) ? posA : turnPointsA[i + 1].pos;
                                            const startTotal = pt.totalDist;
                                            const endTotal = (i === turnPointsA.length - 1) ? totalDistA : turnPointsA[i + 1].totalDist;
                                            if (Math.abs(endX - startX) < 1) return null;
                                            const yOffset = blueBaseY + i * lineHeight;
                                            return (
                                                <g key={`a-${i}`}>
                                                    <line x1={`${(startX/viewMax)*100}%`} y1={yOffset} x2={`${(endX/viewMax)*100}%`} y2={yOffset} stroke="#2563eb" strokeWidth="2" markerEnd="url(#arrow-blue)" opacity="0.6" />
                                                    <text x={`${((startX+endX)/2/viewMax)*100}%`} y={yOffset-3} fill="#2563eb" fontSize="10" textAnchor="middle">{Math.round(Math.abs(endX-startX))}m</text>
                                                    {renderLinearMarkers('A', startTotal, endTotal, startX, endX, yOffset)}
                                                </g>
                                            );
                                        })}
                                        {turnPointsB.map((pt, i) => {
                                            const startX = pt.pos;
                                            const endX = (i === turnPointsB.length - 1) ? posB : turnPointsB[i + 1].pos;
                                            const startTotal = pt.totalDist;
                                            const endTotal = (i === turnPointsB.length - 1) ? totalDistB : turnPointsB[i + 1].totalDist;
                                            if (Math.abs(endX - startX) < 1) return null;
                                            const yOffset = redBaseY + i * lineHeight;
                                            return (
                                                <g key={`b-${i}`}>
                                                    <line x1={`${(startX/viewMax)*100}%`} y1={yOffset} x2={`${(endX/viewMax)*100}%`} y2={yOffset} stroke="#e11d48" strokeWidth="2" markerEnd="url(#arrow-red)" opacity="0.6" />
                                                    <text x={`${((startX+endX)/2/viewMax)*100}%`} y={yOffset+12} fill="#e11d48" fontSize="10" textAnchor="middle">{Math.round(Math.abs(endX-startX))}m</text>
                                                    {renderLinearMarkers('B', startTotal, endTotal, startX, endX, yOffset)}
                                                </g>
                                            );
                                        })}
                                    </svg>
                                    <div className="absolute left-0 -top-1 w-0.5 h-3 bg-stone-400"></div>
                                    <div className="absolute left-0 -top-6 text-xs font-bold text-stone-500 -translate-x-1/2">0m</div>
                                    {mode === 'meeting' && <><div className="absolute right-0 -top-1 w-0.5 h-3 bg-stone-400"></div><div className="absolute right-0 -top-6 text-xs font-bold text-stone-500 translate-x-1/2">{distance}m</div></>}
                                    {mode === 'catching' && <><div className="absolute w-0.5 h-3 bg-purple-300 -top-1" style={{ left: `${(headStart/viewMax)*100}%` }}></div><div className="absolute text-xs font-bold text-purple-400 -top-6 -translate-x-1/2" style={{ left: `${(headStart/viewMax)*100}%` }}>{headStart}m</div></>}
                                    <div className="absolute transition-none z-30" style={{ left: `${(posA/viewMax)*100}%`, top: '-50px', transform: `translateX(-50%) scaleX(${dirA===1?-1:1})` }}>
                                        <div className="flex flex-col items-center"><span className="text-4xl md:text-5xl filter drop-shadow-md">ğŸƒâ€â™‚ï¸</span><span className="text-[10px] font-bold text-blue-600 bg-white/90 px-1 rounded shadow-sm whitespace-nowrap" style={{transform:`scaleX(${dirA===1?-1:1})`}}>å°æ˜</span></div>
                                    </div>
                                    <div className="absolute transition-none z-20" style={{ left: `${(posB/viewMax)*100}%`, top: '-50px', transform: `translateX(-50%) scaleX(${dirB===1?-1:1})` }}>
                                        <div className="flex flex-col items-center"><span className="text-4xl md:text-5xl filter drop-shadow-md inline-block">ğŸƒâ€â™€ï¸</span><span className="text-[10px] font-bold text-rose-500 bg-white/90 px-1 rounded shadow-sm whitespace-nowrap" style={{transform:`scaleX(${dirB===1?-1:1})`}}>å°çº¢</span></div>
                                    </div>
                                </div>
                            )}

                            {/* ç¯å½¢è·‘é“è§†å›¾ */}
                            {trackType === 'circular' && (
                                <div className="relative w-full h-full flex items-center justify-center">
                                    {/* æ‰©å¤§ viewBox ä»¥é€‚åº”æ›´å¤§çš„è·‘é“ */}
                                    <svg width="100%" height="100%" viewBox="-320 -320 640 640" className="overflow-visible">
                                        <circle cx="0" cy="0" r="180" fill="none" stroke="#e7e5e4" strokeWidth="15" />
                                        <line x1="0" y1="-170" x2="0" y2="-190" stroke="#78716c" strokeWidth="3" />
                                        <text x="0" y="-195" fontSize="14" fill="#78716c" textAnchor="middle" fontWeight="bold">èµ·ç‚¹</text>

                                        {turnPointsA.map((pt, i) => {
                                            const endPos = (i === turnPointsA.length - 1) ? posA : turnPointsA[i + 1].pos;
                                            const r = circleRadiusA - (i * spiralGap); 
                                            const startTotal = pt.totalDist;
                                            const endTotal = (i === turnPointsA.length - 1) ? totalDistA : turnPointsA[i + 1].totalDist;
                                            return (
                                                <g key={`ca-${i}`}>
                                                    {getArcPath(pt.pos, endPos, r, "#2563eb")}
                                                    {renderCircularMarkers('A', startTotal, endTotal, r)}
                                                </g>
                                            );
                                        })}
                                        {turnPointsB.map((pt, i) => {
                                            const endPos = (i === turnPointsB.length - 1) ? posB : turnPointsB[i + 1].pos;
                                            const r = circleRadiusB + (i * spiralGap);
                                            const startTotal = pt.totalDist;
                                            const endTotal = (i === turnPointsB.length - 1) ? totalDistB : turnPointsB[i + 1].totalDist;
                                            return (
                                                <g key={`cb-${i}`}>
                                                    {getArcPath(pt.pos, endPos, r, "#e11d48")}
                                                    {renderCircularMarkers('B', startTotal, endTotal, r)}
                                                </g>
                                            );
                                        })}

                                        {(() => {
                                            const posACircle = getCirclePos(posA, circleRadiusA - (turnPointsA.length - 1) * spiralGap);
                                            const posBCircle = getCirclePos(posB, circleRadiusB + (turnPointsB.length - 1) * spiralGap);
                                            return (
                                                <>
                                                    <g transform={`translate(${posACircle.x}, ${posACircle.y})`}>
                                                        <g transform={`rotate(${posACircle.rotation + 90})`}>
                                                            <text fontSize="24" textAnchor="middle" dy="8" style={{transform: `scaleX(${dirA===1?-1:1})`}}>ğŸƒâ€â™‚ï¸</text>
                                                        </g>
                                                    </g>
                                                    <g transform={`translate(${posBCircle.x}, ${posBCircle.y})`}>
                                                        <g transform={`rotate(${posBCircle.rotation + 90})`}>
                                                            <text fontSize="24" textAnchor="middle" dy="8" style={{transform: `scaleX(${dirB===1?-1:1})`}}>ğŸƒâ€â™€ï¸</text>
                                                        </g>
                                                    </g>
                                                </>
                                            )
                                        })()}
                                    </svg>
                                </div>
                            )}

                        </div>

                        {/* æŒ‰é’® */}
                        <div className="flex gap-4 items-center">
                            <button onClick={() => {
                                if (isPausedAtEvent) { handleContinue(); } 
                                else setIsRunning(!isRunning);
                            }} className={`flex-1 text-white text-base md:text-lg font-bold py-3 md:py-4 rounded-xl shadow-lg flex items-center justify-center gap-2 transition-transform active:scale-95 ${isPausedAtEvent ? 'bg-blue-500 hover:bg-blue-600' : (isRunning?'bg-amber-400 hover:bg-amber-500':'bg-emerald-500 hover:bg-emerald-600')}`}>
                                {isPausedAtEvent ? <><Icon path={Icons.Continue} /> ç»§ç»­å¥”è·‘</> : (isRunning ? <><Icon path={Icons.Pause} /> æš‚åœ</> : <><Icon path={Icons.Play} /> å¼€å§‹è¿è¡Œ</>)}
                            </button>
                            <button onClick={() => resetPositions(mode, false)} className="bg-white hover:bg-stone-100 text-stone-500 font-bold p-3 md:p-4 rounded-xl shadow border-2 border-stone-100 transition-colors flex items-center gap-2" title="é‡ç½®">
                                <Icon path={Icons.Reset} /> <span>é‡ç½®</span>
                            </button>
                        </div>

                        {/* æ•°æ®é¢æ¿ */}
                        <div className="grid grid-cols-3 gap-2 md:gap-4">
                            <div className="bg-blue-50 text-blue-800 p-2 md:p-3 rounded-xl flex flex-col items-center justify-center">
                                <span className="text-[10px] md:text-xs font-bold opacity-60 text-center">å°æ˜ç´¯è®¡é‡Œç¨‹</span>
                                <span className="font-mono font-bold text-lg md:text-xl tabular-nums">{Math.round(totalDistA)}</span>
                            </div>
                            <div className="bg-amber-50 text-amber-800 p-2 md:p-3 rounded-xl flex flex-col items-center justify-center border-2 border-amber-100">
                                <span className="text-[10px] md:text-xs font-bold opacity-60">æ€»æ—¶é—´</span>
                                <span className="font-mono font-bold text-xl md:text-2xl tabular-nums">{currentTime.toFixed(1)}s</span>
                            </div>
                            <div className="bg-rose-50 text-rose-800 p-2 md:p-3 rounded-xl flex flex-col items-center justify-center">
                                <span className="text-[10px] md:text-xs font-bold opacity-60 text-center">å°çº¢ç´¯è®¡é‡Œç¨‹</span>
                                <span className="font-mono font-bold text-lg md:text-xl tabular-nums">{Math.round(totalDistB)}</span>
                            </div>
                        </div>
                    </div>

                    <footer className="mt-6 mb-4 text-center text-stone-400 text-xs font-bold opacity-80">
                        @å­™ç»´åˆšæ•™è‚²ç ”ç©¶é™¢
                    </footer>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
